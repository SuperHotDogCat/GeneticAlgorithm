# コード解説
コードを書くにあたり、
<p>
- 渡る前の岸に人がいる状態
</p>
<p>
- 渡る側の岸に人がいる状態
</p>
<p>
- ボートの位置
</p>
<p>
これらの状態を管理することを考えると、classでまとめた方が良いと考えたので, 状態はEnvというclassで管理を行うことにした。
</p>

## class Env の仕様
<p>
assignment4_3_A.pyのclassを元にclass Envの解説を行う。class Envは初期化の際に何組のカップルがいるかを指定できるようにした。
</p>

### properties

<p>
- left, island, right: List[List[int]]
</p>
<p>
それぞれ渡る前の岸, 渡る途中にある島, 渡る側の岸を意味する。Nで組数を指定し, 1, 0でその岸にいるかどうかを判断する。例えばN = 3なら最初のleftの状態は
[[1,1], [1,1], [1,1]]である。
ちなみに、assignment4_1ではislandのpropertyはない
</p>
<p>
- boat
</p>
<p>
ボートがどこにあるのかを指定するproperty。assignment4_1なら0で渡る前の岸, 1で渡る側の岸を意味する。assignment4_2なら0で渡る前の岸, 1で島, 2で渡る側の岸を意味する。
</p>
<p>
- score
</p>
<p>
A*探索のために必要となる値。授業中にあったように定義を行う。A*の計算方法は後に述べる。
</p>
<p>
depth
</p>
<p>
A*探索のために必要となる値。Envの探索nodeの深さを保持しておくために使う
</p>

### methods

<p>
- set_state
</p>
<p>
Env classを引数から制作する関数
</p>
<p>
- __eq__
</p>
<p>
状態が等しいとはどういう状態であるかを定義する関数。今回は渡る前の岸, 島, 渡る側の岸の状態が等しければ状態が等しいとして定義を行うことにした。
</p>
<p>
- __repr__, __str__
</p>
<p>
デバック用のmethod, print関数などで綺麗に表示してくれるために追加
</p>
<p>
- __lt__
</p>
<p>
A*探索の際, Env classのscorepropertyの大小を考えなければならない状況がでてくる。その時にEnv classの大小比較ができると便利なので追加したメソッド
</p>
<p>
- set_state_from_index
</p>
<p>
状態に島が追加される時, ボート移動後の状態を出力するのがやや混み行った操作となるので追加した関数。
</p>
<p>
- next_states
</p>
<p>
やや実装が混みいるが, 以下の手順で主に現在の状態から次の状態を求めた。
</p>
1. ボートの位置とボートの出発先と目的地を元に, 移動候補を制作
</p>
</p>
2. 移動候補が有効な移動先であることを(is_valid_state関数)確認し, 既に訪れた状態でなければ移動候補に追加する。
</p>

# 関数

<p>
- is_valid_state
</p>
<p>
移動先の状態が有効(ある男の妻が別の男と一緒にいないこと)であるかを確かめる関数。
</p>
<p>
- dfs, bfs, A*
</p>
<p>
上までで実装した関数とクラスを使い,dfs, bfs, A*アルゴリズムを実行していく関数。dfs, bfsは用いるデータ構造はdequeであり, A*はminheapを用いた。
</p>

# A*のf値の決め方
$f$値の計算のためにはある状態からゴール状態までの最小コストの妥当な下界$h(n)$を推定しなければならない。それぞれの課題でどのように考えたのかを記す。

### assignment4_1
leftに人が1人いる時, 船に2人乗せてrightに運んだとしても, rightからleftに戻るために最低1人は船に乗ってまたleftに戻らなければならないと考え, leftに1人の人がいるとき, ゴール状態まで2回の手順が発生するはずである。また, ボートがrightにある時はボートをleftに戻す操作が必要なため1回の手順が発生するはずである。
これらのことからassignment4_1における$h(n)$は

$$
h(n) = \left\{
\begin{array}{ll}
2×(\text{left}にいる人数) & ボートが\text{left}にある場合 \\
2×(\text{left}にいる人数)+1 & ボートが\text{right}にある場合
\end{array}
\right.
$$
とした。

### assignment4_2

<p>
leftに人が1人いる時, 船に2人乗せてrightに運んだとしても, rightからleftに戻るために最低1人は船に乗ってislandを経由してleftに戻らなければならないと考え, leftに1人の人がいるとき, ゴール状態まで4回の手順が発生するはずである。</p><p>また, islandに人が1人いる時は同様の議論によりゴール状態まで2回の手順が発生するはずである。</p>
<p>
ボートがrightにある時はボートをislandを経由してleftに戻す操作が必要なため2回の手順が発生するはずである。</p>
<p>
ボートがislandにある時は同様にleftに船を運ぶために1回の手順が発生するはずである。
</p>
これらのことからassignment4_2における$h(n)$は

$$
h(n) = \left\{
\begin{array}{ll}
4×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数)& \\ ボートが\text{left}にある場合 \\\\
4×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数) + 1& \\ ボートが\text{island}にある場合 \\\\
4×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数) + 2& \\ ボートが\text{right}にある場合 \\
\end{array}
\right.
$$
とした。

### assignment4_3

assignment4_3では, 直接leftからrightへの移動が可能となったため, leftに人がいるときの処理がことなる。このことからassignment4_2における$h(n)$は

$$
h(n) = \left\{
\begin{array}{ll}
2×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数)& \\ ボートが\text{left}にある場合 \\\\
2×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数) + 1& \\ ボートが\text{island}にある場合 \\\\
2×(\text{left}にいる人数)+ \\2×(\text{right}にいる人数) + 2& \\ ボートが\text{right}にある場合 \\
\end{array}
\right.
$$

とした。ところで, ボードがrightにあるとき, leftに直接移動できるため+2ではなく+1の方が正しいが実験したところ+2のままの方が探索が早かったため, +2のままにしている。

これらの$h(n)$の定義はコーナーケースを考えた時に必ずしも当てはまらない場合があるが, この$h(n)$の定義が最もよく動作していると思えたので採用した。

# Result
num_nodesの値が-1の時はどれだけノードを展開しても答えに辿り着けなかったことを意味する。
### assignment4_1
dfs
```
N: num_nodes
1: 1
2: 16
3: 53
4: -1
5: -1
6: -1
```
bfs
```
N: num_nodes
1: 1
2: 20
3: 55
4: -1
5: -1
6: -1
```
A*
```
N: num_nodes
1: 1
2: 19
3: 55
4: -1
5: -1
6: -1
```

### assignment4_2
dfs
```
N: num_nodes
1: 7
2: 76
3: 376
4: 2176
5: 1665
6: 24225
```
bfs
```
N: num_nodes
1: 9
2: 133
3: 756
4: 3442
5: 14389
6: 計測不能
```
A*
```
N: num_nodes
1: 8
2: 60
3: 192
4: 1271
5: 891
6: 9480
```

### assignment4_3
dfs
```
N: num_nodes
1: 5
2: 27
3: 268
4: 774
5: 1409
6: 11496
```
bfs
```
N: num_nodes
1: 5
2: 82
3: 547
4: 2729
5: 11899
6: 測定不能
```
A*
```
N: num_nodes
1: 5
2: 50
3: 172
4: 648
5: 1046
6: 3582
``` 

### 問題1
assignment4_1より, N = 3の時のノードの展開数はdfsが53と最も小さく, A*とbfsは55と2個ノードの展開が多かった。

### 問題2
assignment4_1より全てのあり得る状態を探索してもN = 4の時は解がないことがわかった。
島を追加した場合はassignment4_2より, N = 4の時でも解答があることが示された。
A*のヒューリスティックに関して, 問題1と同じ$h(n)$, つまりislandを考慮しない評価関数を使った結果が以下の通りである。
```
N: num_nodes
1: 8
2: 60
3: 325
4: 1182
5: 2928
6: 10050
```
このことから, islandによるゴールまでのコストを考慮した時の方がN = 3, 5, 6の時に大幅な探索ノードの減少が見られ, ヒューリスティック関数の決定方法により探索方法が減らせることがわかった。
assignment4_2ではdfs, bfsよりもNが大きいほどA*探索の方が効率的に解答を求めることができた。

### 問題3
<p>
拡張性の高いコードを書いたので, assignment4_3ではassignment4_2のmovesという配列に直接岸の間の移動方法を増やすことですぐに実装ができた。ただ移動方法が増えただけなのでassignment4_2と同じように解答は存在する。
</p>
<p>
探索効率としてはA*がかなり早く解答を見つけられていた。
</p>

$h(n)$の定義次第ではdfsと同じぐらいか少し効率が効率が良いぐらいであった。以下に記す。

assignment4_1と同じ$h(n)$の場合

```
N: num_nodes
1: 5
2: 45
3: 316
4: 2338
5: 1322
6: 10022
```

assignment4_2と同じ$h(n)$の場合

```
N: num_nodes
1: 5
2: 45
3: 250
4: 600
5: 1446
6: 11019
```

### 問題4
<p>
N = 5以上の時, islandがない場合は解がない。islandがある場合, N = 6まで解があることが確かめられた。このことからislandがある場合はどのNでも運べることが予想できる。
</p>
